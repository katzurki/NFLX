(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ?
        module.exports = factory() :
        typeof define === 'function' && define.amd ? define(
            factory) :
        (global.parseSRT = factory());
}(this, (function () {
    'use strict';

    function toSeconds(time) {
        var t = time.split(':');

        try {
            var s = t[2].split(',');

            if (s.length === 1) {
                s = t[2].split('.');
            }

            return parseFloat(t[0], 10) * 3600 +
                parseFloat(t[1], 10) * 60 + parseFloat(s[
                    0], 10) + parseFloat(s[1], 10) / 1000;
        }
        catch (e) {
            return 0;
        }
    }

    function nextNonEmptyLine(linesArray, position) {
        var idx = position;

        while (!linesArray[idx]) {
            idx++;
        }

        return idx;
    }

    function lastNonEmptyLine(linesArray) {
        var idx = linesArray.length - 1;

        while (idx >= 0 && !linesArray[idx]) {
            idx--;
        }

        return idx;
    }

    function parseSRT() {
        var data = arguments.length > 0 && arguments[
            0] !== undefined ? arguments[0] : '';

        var subs = [];
        var lines = data.split(/(?:\r\n|\r|\n)/gm);
        var endIdx = lastNonEmptyLine(lines) + 1;
        var idx = 0;
        var time = void 0;
        var text = void 0;
        var sub = void 0;

        for (var i = 0; i < endIdx; i++) {
            sub = {};
            text = [];

            i = nextNonEmptyLine(lines, i);
            sub.id = parseInt(lines[i++], 10);

            time = lines[i++].split(/[\t ]*-->[\t ]*/);

            sub.start = toSeconds(time[0]);

            idx = time[1].indexOf(' ');
            if (idx !== -1) {
                time[1] = time[1].substr(0, idx);
            }
            sub.end = toSeconds(time[1]);

            while (i < endIdx && lines[i]) {
                text.push(lines[i++]);
            }

            sub.text = text.join('\\N')
                .replace(
                    /\{(\\[\w]+\(?([\w\d]+,?)+\)?)+\}/gi
                    , '');

            sub.text = sub.text.replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');

            sub.text = sub.text.replace(
                /&lt;(\/?(font|b|u|i|s))((\s+(\w|\w[\w\-]*\w)(\s*=\s*(?:".*?"|'.*?'|[^'">\s]+))?)+\s*|\s*)(\/?)&gt;/gi
                , '<$1$3$7>');
            sub.text = sub.text.replace(/\\N/gi, "\n");

            subs.push(sub);
        }

        return subs;
    }

    return parseSRT;

})));

var LANG = "EN"
var line_limit = max_cps = normal_cps = 0;

switch (LANG) {

case "RU":
    line_limit = 39
    normal_cps = 17
    max_cps = 22.1
    break;

case "FR":

default:
    line_limit = 42
    normal_cps = 20
    max_cps = 26
}

var reportHtml =
    '<head><script>var z = function(){ var s=document.getElementsByClassName("cSpace");for(x of s){x.className === "cSpace" ? (x.className="cSpace of0"):(x.setAttribute("class","cSpace"))}};</script><style>body{background-color:#212121}.of0{visibility:hidden;color:#000!important;}.cSpace{color:#00fa00;visibility:visible;}.StyledTextEditor{font-family:Netflix-Sans;line-height:1.3;margin:2px;white-space:nowrap;overflow:hidden;font-variant-ligatures:none;position:relative;pointer-events:none}.StyledTextEditor .ltr{unicode-bidi:embed;direction:ltr}.TimedTextEvent{font-family:Netflix-Sans;font-size:1.3rem;font-weight:400;line-height:2rem;margin-top:.5rem;display:-webkit-box;display:-moz-box;display:-webkit-flex;display:-ms-flexbox;display:box;display:flex;-webkit-box-orient:vertical;-moz-box-orient:vertical;-o-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;border:1px solid transparent;-webkit-transition:height 250ms ease,border 150ms ease;-moz-transition:height 250ms ease,border 150ms ease;-o-transition:height 250ms ease,border 150ms ease;-ms-transition:height 250ms ease,border 150ms ease;transition:height 250ms ease,border 150ms ease}.TimedTextEvent .details{padding-top:.5rem;padding-left:1rem;padding-right:1rem;display:-webkit-box;display:-moz-box;display:-webkit-flex;display:-ms-flexbox;display:box;display:flex;-webkit-box-orient:horizontal;-moz-box-orient:horizontal;-o-box-orient:horizontal;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}.TimedTextEvent .details .timing{-webkit-flex-shrink:0;flex-shrink:0;display:-webkit-box;display:-moz-box;display:-webkit-flex;display:-ms-flexbox;display:box;display:flex;-webkit-box-orient:vertical;-moz-box-orient:vertical;-o-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:8rem}.issue{font-size:16;vertical-align:middle;font-family:Netflix-Sans;position:relative;top:-1px}.TimedTextEvent .details .timing .TimeCode{color:rgba(255,255,255,.54);padding:0 .5rem;border-radius:1rem;white-space:nowrap}.TimedTextEvent .details .content{-webkit-box-flex:1;-moz-box-flex:1;-o-box-flex:1;-ms-box-flex:1;box-flex:1;-webkit-flex-grow:1;flex-grow:1;display:-webkit-box;display:-moz-box;display:-webkit-flex;display:-ms-flexbox;display:box;display:flex;-webkit-box-orient:vertical;-moz-box-orient:vertical;-o-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;padding-left:2rem;padding-bottom:.5rem;width:24rem}.TimedTextEvent .details .content .header{display:-webkit-box;display:-moz-box;display:-webkit-flex;display:-ms-flexbox;display:box;display:flex;-webkit-box-orient:horizontal;-moz-box-orient:horizontal;-o-box-orient:horizontal;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}.TimedTextEvent .details .content .header .index{color:rgba(255,255,255,.66)}.TimedTextEvent .details .content .header .duration{color:rgba(255,255,255,.54);margin-left:auto;border-radius:1rem}.TimedTextEvent .details .content .StyledTextEditor{color:rgba(255,255,255,.87);min-height:3.2rem;margin-top:.3rem}img{display:table-cell;vertical-align:middle}.TimedTextEvent .footer{height:.5rem;border-bottom:2px solid rgba(0,0,0,.77);margin-left:1rem;margin-right:1rem}.outline{color:#000;position:relative;left:350%;} i{ font-style: italic!important; font-family: serif!important}#feedback{height:0;width:65px;position:fixed;right:0;top:50%;z-index:1000;transform:rotate(-90deg);-webkit-transform:rotate(-90deg);-moz-transform:rotate(-90deg);-o-transform:rotate(-90deg)}#feedback a{display:block;background:#06c;height:15px;width:165px;padding:8px 16px;color:#fff;font-family:Arial,sans-serif;font-size:17px;font-weight:700;text-decoration:none;border-bottom:solid 1px #333;border-left:solid 1px #333;border-right:solid 1px #fff}#feedback a:hover{background:#ccc}</style><body><div id="stick"><button style="block; color=seagreen2; position: relative; top: -1px; left: 665px;" onclick="z()">👀</button></div>';

var our_clq = document.location.href.toString()
    .split("=")[1].split(":")[2]
var clq_pattern = new RegExp(
    '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
    , 'i');

if (!our_clq || !clq_pattern.test(our_clq)) {
    alert("You must be in an Originator task!");
    throw new Error
}

if (!clq_pattern.test(our_clq)) {
    alert("The CLQ is invalid: " + our_clq + "\n" +
        "Please report me to the developer.");
    throw new Error
}

var lsJson = localStorage["clq:origination:" + our_clq]
if (!lsJson) {
    alert("Timed text events not found in localStorage\nfor CLQ: " +
        our_clq + "\n" + "If the CLQ is correct and" + "\n" +
        "\"Save to local storage\" is enabled in Settings," +
        "\n" + "save the task and try again.");
    throw new Error
}

var json_obj = JSON.parse(lsJson)
var src = json_obj["events"]
var fps_ = json_obj["meta"]["fps"];
var fps = fps_.split("_")[1] / 100
//From {"fps":"FPS_2500"}
//var proposed_fps = prompt("Framerate set to: " + fps + " fps.\n\nEnter new value like 2997, 2500 or 23976023976023978:");
try {
    if (proposed_fps) {
        var int_fps = proposed_fps.substring(0, 2);
        var decimal_fps = proposed_fps.substring(2, proposed_fps
            .length);
        fps_ = "FPS" + "_" + int_fps + decimal_fps
        fps = (int_fps + "." + decimal_fps) * 1;
    }
}
catch (e) {}

var frms = 1000 / fps

function srtName(suffix = "", extension = ".srt") {
    var s = document
        .getElementsByClassName(
            "cpe-page-menu-label")[0]
        .innerText
    var srtName = (s.replace(/[ ]/g
                , '_')
            .replace(/[^a-z0-9_]/gi
                , '') + "_" + suffix + extension
        ) //This gets rid of all punctuation, spaces and non-English letters
        .trim() //resulting in a name like 14545_El_Burrito_A_Breaking_Fat_Movie_FPS_2500.srt
    if (!srtName) srtName = our_clq +
        "_" + suffix +
        ".srt" //Fallback measure. Useful for debugging later
    return srtName
}

function frames2tcf(framenumber, framerate =
    fps) { //frames to 00:01:02:24 format
    var seconds_float = framenumber / framerate
    var seconds_int = Math.floor(seconds_float)
    var seconds_frac = seconds_float - seconds_int
    var frames = Math.round(seconds_frac * framerate) + ''
    var date = new Date(0);
    date.setSeconds(seconds_int);
    var timeString = date.toISOString()
        .substr(11, 8)
    if (frames.length == 1) frames = "0" + frames
    var timecodef = timeString + ":" + frames
    return timecodef
}

function frames2timecode(frames) { //frames to 00:01:02,000 format
    var milliseconds = Math.round(
        frames * frms)
    var srt_timecode = TimeConversion(
        milliseconds)
    return srt_timecode
}

function array2srt(events_object) {
    var ordered_events = []
    for (var id in events_object) {
        try {
            var type_fn = events_object[id]["type"]
            if (type_fn === "fn") {
                events_object[id]["txt"] += "<b></b>";
                type_fn = undefined;
                delete(type_fn)
            }
        }
        catch (e) {}
        ordered_events.push([
            events_object[id][
                "start"
            ]
            , events_object[id][
                "end"
            ], events_object[id]
            ["txt"]
            , events_object[id]
            ["styles"]
            , events_object[id]
            ["rgn"]
        ])
    }
    ordered_events.sort(function (a
        , b) {
        return a[0] - b[0];
    }); //Array sorted by in_cues, sequentially
    var index = 0
    var srt_txt = ''
    for (event of ordered_events) {
        index++
        var start = frames2timecode(
            event[0])
        var end = frames2timecode(event[
            1])
        var content = event[2]
        try {
            if (typeof event[3][0]["type"] !== "undefined") {
                if (event[3][0]["type"] == "italic") {
                    content = italicize(content, event[3])
                }
            }
        }
        catch (e) {}

        try {
            if (typeof event[4] !== "undefined") {
                if (event[4] == "top") {
                    content = "{\\an8}" + content
                }
            }
        }
        catch (e) {}

        try {
            if (event["type"] == "fn") {
                content += '<b></b>'
            }
        }
        catch (e) {}
        console.log(content)
        var current_event = index +
            "\n" + start + " --> " +
            end +
            "\n" + content + "\n"
        srt_txt += current_event + "\n"
    }
    return srt_txt
}

function italicize(content, italics_array) {
    position_offset = 0
    for (var italic of italics_array) {
        var position_from = italic["from"] + position_offset;
        position_offset += 3
        content = [content.slice(0, position_from), "<i>", content
            .slice(position_from)
        ].join('')
        var position_to = italic["to"] + position_offset;
        position_offset += 4
        content = [content.slice(0, position_to), "</i>", content
            .slice(position_to)
        ].join('')
    }
    return content
}

function download(filename, text) {
    var element = document
        .createElement('a');
    element.setAttribute('href'
        , 'data:text/plain;charset=utf-8,' +
        encodeURIComponent(text));
    element.setAttribute('download'
        , filename);
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
}

function TimeConversion(duration) {
    let time = parseDuration(duration)
    return formatTimeHMSS(time)
}

function parseDuration(duration) {
    let remain = duration
    let hours = Math.floor(remain / (
        1000 * 60 * 60))
    remain = remain % (1000 * 60 * 60)
    let minutes = Math.floor(remain / (
        1000 * 60))
    remain = remain % (1000 * 60)
    let seconds = Math.floor(remain / (
        1000))
    remain = remain % (1000)
    let milliseconds = remain
    return {
        hours
        , minutes
        , seconds
        , milliseconds
    }
}

function formatTimeHMSS(o) {
    let hours = o.hours.toString()
    if (hours.length === 1) hours =
        '0' + hours
    let minutes = o.minutes.toString()
    if (minutes.length === 1) minutes =
        '0' + minutes
    let seconds = o.seconds.toString()
    if (seconds.length === 1) seconds =
        '0' + seconds
    let milliseconds = o.milliseconds
        .toString()
    if (milliseconds.length === 1)
        milliseconds = '00' +
        milliseconds
    if (milliseconds.length === 2)
        milliseconds = '0' +
        milliseconds
    return hours + ":" + minutes + ":" +
        //Example: 00:01:02,999 -- note that the SRT spec calls for a comma, not a period!
        seconds + "," +
        milliseconds
}

function leftFillNum(num, targetLength) {
    return num.toString()
        .padStart(targetLength, 0);
}

var SRT = parseSRT(array2srt(JSON.parse(localStorage[
    "clq:origination:" + our_clq])["events"]));
var issues = []
var events_detected = 0

for (event of SRT) {
    var start_time = event["start"]
    var end_time = event["end"]
    var delta = end_time - start_time
    var start_frames = Math.round(start_time * fps)
    var end_frames = Math.round(end_time * fps)
    var start_tcf = frames2tcf(start_frames)
    var end_tcf = frames2tcf(end_frames)
    var id = event["id"]
    var _id = leftFillNum(id, 4)
    var eventIssue = []
    var eventTxt = event["text"]
    var eventOriginalTxt = event["text"]
    var eventIsFn = false
    if (eventTxt.indexOf("<b></b>") !== -1) {
        eventIsFn = true;
        _id +=
            '<span class="outline" style="color: purple; position: relative; top: 0px; left: 137px;">🅵🅽</span>'
    }
    eventTxt = eventTxt.replace(/(<([^>]+)>)/ig, "");
    eventTxt = eventTxt.replace(/{.an.}/ig, "");
    if (eventTxt.indexOf("\n") !== -1 &&
        eventTxt.indexOf("\n-") == -1 &&
        eventTxt.replace("\n", " ")
        .length <= line_limit && !eventIsFn) {
        eventIssue.push("🚫 Can fit on one line");
    }

    if (eventTxt.indexOf("...") !== -1) {
        eventIssue.push(
            "⚠️ Legacy ellipsis not required. Consider using U+2026: …"
        );
    }

    if (eventTxt.indexOf("!?") !== -1) {

        eventIssue.push(
            "⚠️ Unconventional punctuation detected. Did you mean to use '?!'"
        )
    }

    if (eventTxt.indexOf(" - ") !== -1) {

        eventIssue.push(
            "⚠️ Instead of hyphen, consider en or em dash: – or —"
        )
    }

    var eventSpecial = false

    var hasSpace = /\s$|^\s/;
    var eventTxt_lines = eventTxt.split("\n");
    var nPos = eventTxt.lastIndexOf("\n");
    var hasSpaceIssue = nPos && (typeof eventTxt[nPos + 1] ==
        "undefined")
    var overLineLimit = false
    var hasDoubleSpace = eventTxt.replace("\n", "")
        .split(/\s\s/)
        .length - 1
    var hasThreeLines = typeof eventTxt_lines[2] !== "undefined"

    for (var line of eventTxt_lines) {
        hasSpaceIssue = (hasSpace.test(line) || hasSpaceIssue)
        if (line.length > line_limit) {
            eventSpecial = line
            overLineLimit = true
        }
    }

    if (hasDoubleSpace) {
        eventIssue.push(
            "⚠️ Double spaces detected, replace with single space"
        );
    }

    if (hasThreeLines) {
        eventIssue.push("🚫 Three lines detected in this event");
    }

    if (hasSpaceIssue) {
        if (eventTxt.length > 1) {
            eventIssue.push(
                "⚠️ One of the lines begins or ends with whitespace"
            );
        }
        else {
            eventIssue.push("🚫 Empty event detected!");
            eventSpecial =
                "<span style='color:red;'>&lt;text cannot be empty&gt;</span>"
        }

    }

    if (overLineLimit) {
        eventIssue.push("🚫 Line over max limit of " + line_limit)
        eventSpecial = [eventSpecial.slice(0, line_limit)
            , "<span style='color: red; text-overflow: fade;'>"
            , eventSpecial.slice(
                line_limit)
        ].join('')
    }

    var totalLength = eventTxt.length

    if (delta * delta > 49) {
        eventIssue.push(
            "🚫 Maximum duration exceeded for current FPS!");
    }

    //    var halfLength = totalLength -        Contrary to official statement,
    //    ( eventTxt.replace(/[ ]/g, '')          Originator does not count
    //            .replace(/[^a-z0-9]/gi          Western punctuation and spaces
    //                , '').length);              as 0.5 characters for CPS.*/
    //
    //    totalLength += (halfLength/(-2))

    var cps = (Math.round((totalLength / delta) * 100)) / 100
    var round_int_cps = Math.round(cps + 0.005);
    var html_cps = ''

    if (cps > (normal_cps + 0.5) && cps < (max_cps + 0.5)) {
        eventIssue.push(
            "⚠️ Reading speed slightly over norm; consider adjusting timings?"
        )
        html_cps =
            '<div><span style="color: gold;">&nbsp;&nbsp;&emsp;' +
            round_int_cps + ' c/s</span></div>'
    }
    else if (cps > (max_cps + 0.5)) {
        eventIssue.push(
            "🚫 Reading speed above maximum! Either truncate text or extend timings!"
        )
        html_cps =
            '<div><span style="color:red;">&nbsp;&nbsp;&emsp;' +
            round_int_cps + ' c/s</span></div>'
    }
    else {
        html_cps =
            '<div><span style="color:silver;">&nbsp;&nbsp;&emsp;' +
            round_int_cps + ' c/s</span></div>'
    }
    var dur_tcf = frames2tcf(delta * fps)
        .substr(6)
    var eventLines = eventTxt.split("\n")
    if (typeof eventIssue !== "undefined" && eventIssue.length > 0) {
        events_detected++;
        log_event = (start_tcf + "    " + eventTxt_lines[0].slice(0
                    , line_limit)
                .padEnd(line_limit + 4, " ") + _id)
            .padEnd(line_limit + 10, " ")
        if (typeof eventTxt_lines[1] !== "undefined") {
            log_event += "\n" + end_tcf + "    " + eventTxt_lines[1]
                .padEnd(line_limit + 8, " ")
        }
        else {
            log_event += "\n" + end_tcf + "      " + " ".padEnd(
                line_limit + 6
                , " ")
        }
        console.log('%c' + log_event
            , 'background: #12343b; color: #66ff00')
        //console.log((+_id+"\n"+start_tcf+"\n"+end_tcf+"\n"+eventTxt).padEnd(50), 'background: #222; color: #bada55');
        console.log(('%c' + eventIssue.join("\n"))
            .padEnd(50)
            , 'background: #FFF; color: #FF0000; font-style: italic; border:solid 1px #000;'
        )
        console.log("┉".repeat(63))

        issue = {
            id: _id
            , issues: eventIssue
            , content: eventTxt
            , contentO: eventOriginalTxt
            , start_tcf: start_tcf
            , end_tcf: end_tcf
            , start_frames: start_frames
            , end_frames: end_frames
            , start_time: start_time
            , end_time: end_time
            , duration: delta
            , cps: cps
            , html_cps: html_cps
            , dur_tcf: dur_tcf
            , special: eventSpecial
        }

        htmlize(issue)

    }
}
if (!events_detected) {
    console.log('%c' + "No issues detected"
        , 'background: #12343b; color: #66ff00')
}

function htmlize(issue) {
    try {
        var original = issue.contentO.replace('<b></b>', '')
            .replace(/{.an.}/g, '')
        var lines = original
    }
    catch (e) {
        var lines = issue.content;
    }
    lines = lines.replace(/\n/g, '⏎');
    lines = lines.replace(/\s/g, "<span class='cSpace'>⎵</span>");
    lines = lines.replace(/⏎/g
        , "<span class='cSpace' style=\"color: #00fa00;\">⏎</span>\n"
    );
    lines = lines.split("\n");

    if (issue.special) {
        var check_length = lines[0].length;
        lines[0] = issue.special
        if (check_length > line_limit) {
            var save_l0 = issue.special.substring(line_limit - 1)
            lines[0] = issue.special.substring(0, line_limit - 1)
                .replace(/\s/g, "<span class='cSpace'>⎵</span>") +
                save_l0
        }
    }

    var timedTextEvent =
        '<div class="TimedTextEvent" style="width: 700px; max-width: 100%;">' +
        '<div class="details">' +
        '<div class="timing"><span class="TimeCode">' + issue
        .start_tcf + '</span>' +
        '<span class="TimeCode">' + issue.end_tcf +
        '</span></div><div class="content"><div class="header">' +
        '<span class="index">' + issue.id +
        '</span>' + issue.html_cps +
        '<span class="duration"><span class="TimeCode">' +
        issue.dur_tcf + '</span></span>' +
        '</div><div class="StyledTextEditor" dir="ltr" style="position:relative; top:-20px;">' +
        '<pre><span>' + lines[0];
    sticky_button = ''
    if (typeof lines[1] == "undefined") {
        lines[1] = ""
    }

    timedTextEvent += '</span><div><span>' + lines[1] +
        '</span></div>'
    if (typeof lines[2] !== "undefined") {
        timedTextEvent += '<div><span style="color:red;">' + lines[
            2] + '</span></div></pre>'
    }
    else {
        timedTextEvent += "</pre>"
    }
    for (each_issue of issue.issues) {
        var issueWithImg =
            '<div style="vertical-align:middle;float:left;">' +
            "<span class='issue'>" + each_issue + "</span></div>"
        timedTextEvent += issueWithImg + "<br />"
    }

    reportHtml += timedTextEvent + "</div></div></div></div></div>"
}

download(srtName("Auto_QC_Log", ".html"), reportHtml)
